WE can save the credentials wioth the help of the 

1. By putting out credentials directly in TF (Not recommneded)
2. By adding the profile in the aws credentials (used widely)
3. Adding details via Env variables (Mostly used in Pipelines Framework)

    export AWS_ACCESS_KEY_ID = "your key"
    export AWS_SECRET_ACCESS_KEY = "your secret access key"
    Run terraform plan .. It must work

4. By installing TF on instances we can assign a role to the ec2 instance so that we can use it more securely and then access directly (Widely used; Best practice; more secured)

############    Day 6  USing STS  ################### 

STS [Secure Token Service] in AWS ; It is used to generate a token for the short time. For Min time we can set ourselves; Max for 12 hours.
It gives access key; secret key and Session Token generation is provided with the expiration date


 Commands followed during the creation of Secure Token Service execution is as follows
 
1. create a user "stsuser" with no permissions --> no policy attached --> add it to the aws credentials file with the same profile name 	 
  aws configure --profile stsuser
  cat ~/.aws/credentials 
  aws s3 ls (Fail)
  
2. Create a role --> For aws account --> Admin Access(Highest Privileage) --> name as "stsassumerole"
  aws s3 ls (Fail)

3. Need to integrate the created User with the role

a. On user End --> Permission --> Need to add a inline policy --> Using template for using the IAM ROle in the AWS CLI --> Change the arn with the arn of the role we need to assume. --> name it as "stsassumerolepolicy"

b. On the Role End --> It needs to trust the user so refer to trust relationships --> Exactly the same as in the https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html

aws s3 ls (Fails) --> Its still assuming that we are executing it with the current user but we need to implement it via the role(that we recently created) --> Follow the command  

a. aws sts assume-role --role-arn arn:aws:iam::972348856143:role/stsassumerole --role-session-name accesss3
  
b. aws sts get-caller-identity --> It shows out the current user in my case gives terraform user
  
To configure which profile to be used 
  
Just edit out the file using -->code ~/.aws/config
Add a profile with the fields role_arn (arn of the role), source_profile(the credential for which we want to assume the role)
  
[profile sts]
role_arn = <arn of the role>
source_profile = <credential for which we want to assume role = stsuser in my case>  
  
For source profile credentails we can verify it via the --> cat ~/.aws/credentials
  
  
then if everything is configured

aws s3 ls --profile sts --> Lists out the s3 bucket lists

This should work as it was working fine for some time now

Try creating any new user--> add credentials in the aws credentails folder --> Do not give any permission to the user then ty accessing suing the command 

aws s3 ls --profile new_user (It will not work)

#########################  END Day 6 ####################################### 

########################## Day 7 Creating VPC via Terraform [7 June 2023] ###############################################

For multiple account the role is configured and centralized account where user is configured then how to configure it suing the Terraform

just add the assume_role block in the provider.tf file

assume_role {
  role_arn = "your_arn"
  session_name = "your seesion name" [It is similiar to as that of the [aws sts --role-arn <arn of the role to be assumed> --role-session-name <your session name>] Also remember the session maxes out at 12 hrs so need to create a new token after that]
}

How to actually create a VPC using the TF ?

1.In VPC there are lots of fields known as Arguments which are needed to fill to host VPC {Some mandatory or Optional}

2. In tf planning if we do not want hassle to cross check then give terraform plan --auto-approve

3. For generating VPC we need the bare minimum as [cidr_block]  OR [ipv4_ipam_pool_id] (Which inturn requires the ipv4_netmask_length to calulcate the cidr range)

While creating a resource block 

resource "aws_vpc" "main" {}

aws_vpc -- represents what type of resource is expected by the provider to create.
main -- represents the name of that resource but standards should be followed like giving it names like this, main, my_vpc, main_vpc

To create vpc we need to provide the cidr ranges which can be easily get by --> search  private ip ranges and based on the requirement add a class range

to save a plan in teraform just add the --> terraform plan -out sample_name.out (File will be generated with such name)

to execute that just use --> terraform apply "sample_name.out" (It would create the vpc resource in aws console we caqn verify)

########################### End Day 7 [7 June 2023] #########################################

########################### Day 8 ##################################################
######################################### END Day 8 ########################################

###########################  Day 9 Creation of Aws 3-tier architecture by using for each, Count in terraform ,  some basic git commands cm [8 June 2023] #########################################

#1st Iteration

# resource "aws_subnet" "this" {
#   # for_each   = toset(["192.168.0.0/27", "192.168.0.32/27", "192.168.0.64/27", " 192.168.0.96/27", "192.168.0.128/27", "192.168.0.160/27"])
#   for_each   = { "1": "192.168.0.0/27", "2":"192.168.0.32/27", "3": "192.168.0.64/27", "4": "192.168.0.96/27", "5": "192.168.0.128/27", "6": "192.168.0.160/27"}
#   vpc_id     = aws_vpc.this.id
#   cidr_block = each.value

#   tags = {
#     Name = "Main_${each.key}"
#   }
# }


# resource "aws_subnet" "this" {
#   # count  = var.no_of_subnets
#   count = length(var.cidr_subnet)

#   #length is used to find the length of list
#   vpc_id = aws_vpc.this.id
#   #element helps us to traverse through the list one element at a time
#   # In terraform a list can have same type of dataype; as in python
#   cidr_block = element(var.cidr_subnet, count.index)
#   tags = {
#     Name = "subnet-${count.index}"
#   }
# }

variable "no_of_subnets" {
  type        = number
  description = "Number of subnets to be created"
  default     = 6 #If variable is not passed then waht value needed to be considered
}

variable "cidr_subnet" {
  type        = list(string)
  description = "List of CIDR range in Subnets"
  default     = ["192.168.0.0/27", "192.168.0.32/27", "192.168.0.64/27", "192.168.0.96/27", "192.168.0.128/27", "192.168.0.160/27"]
}

#terraform console used to checkout the functions functioanlity of TF in the console itself.

# Now we need to create public and private subnets as per our discussions

# resource "aws_subnet" "this" {
#   # for_each   = toset(["192.168.0.0/27", "192.168.0.32/27", "192.168.0.64/27", " 192.168.0.96/27", "192.168.0.128/27", "192.168.0.160/27"])
#   for_each   = { "public_subnet_1" : "192.168.0.0/27", "public_subnet_2" : "192.168.0.32/27", "private_subnet_1" : "192.168.0.64/27", "private_subnet_2" : "192.168.0.96/27", "private_subnet_3" : "192.168.0.128/27", "6" : "192.168.0.160/27" }
#   vpc_id     = aws_vpc.this.id
#   cidr_block = each.value
#   availability_zone = 

#   tags = {
#     Name = "Main_${each.key}"
#   }
# }

#for_each is widely usedas compared to the count

#But we need to consider the point of different AVALABILTY ZONES
# As per our requiremnts we need to have the 2 Avalibilty zones

#Search for it in the arguments refrences

#pass avalibility zones but it takse string as input and we need to provide the list here

#we need to pass 1 public and 2 private in each AZ i.e. for 6 subnets we will consider here 2 AZ i.e. us-east-1a, us-east-1b

# 1 way is by creating 1 subnet for AZ 1 and another subnet for AZ2

resource "aws_subnet" "subnet_az1" {
  # for_each   = toset(["192.168.0.0/27", "192.168.0.32/27", "192.168.0.64/27", " 192.168.0.96/27", "192.168.0.128/27", "192.168.0.160/27"])
  for_each          = { "public_subnet_1_az1" : "192.168.0.0/27", "private_subnet_1_az1" : "192.168.0.32/27", "private_subnet_2_az1" : "192.168.0.64/27" }
  vpc_id            = aws_vpc.this.id
  cidr_block        = each.value
  availability_zone = "us-east-1a"

  tags = {
    Name = "Subnet_${each.key}"
  }
}

resource "aws_subnet" "subnet_az2" {
  # for_each   = toset(["192.168.0.0/27", "192.168.0.32/27", "192.168.0.64/27", " 192.168.0.96/27", "192.168.0.128/27", "192.168.0.160/27"])
  for_each          = { "public_subnet_1_az2" : "192.168.0.96/27", "private_subnet_1_az2" : "192.168.0.128/27", "priavte_subnet2_az2" : "192.168.0.160/27" }
  vpc_id            = aws_vpc.this.id
  cidr_block        = each.value
  availability_zone = "us-east-1b"

  tags = {
    Name = "Subnet_${each.key}"
  }
}

#But the above process goes through the lot of code repetation


########################### End Day 9 [8 June 2023] #########################################

########################## Day 10 [] #######################################################

Disusions about the JIRA board

To create a branch using the story provided we should use the following like [orgname-jira.story.no-branchname] this is the standard followed throughout

create variable.tf
variable "cidr_for_vpc" {
    description = "the cidr range for VPC"
    type = string
}

#If we want to input the value from the user then we do not need to add the "default"


enable_dns_support - (Optional) A boolean flag to enable/disable DNS support in the VPC. Defaults true.

enable_dns_hostnames - (Optional) A boolean flag to enable/disable DNS hostnames in the VPC. Defaults false.

What if we need ourr resources into multiple avalilale zones then we need to add a Data Source to feed that how many number of avalibilty zones are there by creating data.tf file

Data source is special kind of block like resource block in TF which actually retrieve the information as per the defination

eg how many AZ available in north virginia

i.e. basically it doesnt create any resource but it actually helps us out in the info about anything available in resources like aws, azure, gcp



eg in this vpc we nned to create eks cluster but its in another foleder with the help of datasource we can get the id of the vpc and pass it to the eks cluster

add data.tf file and search for the datasource in terrafrom get this template from the below
From here we will get the final 

data "aws_availability_zones" "this" {
  all_availability_zones = true
  filter {
    name   = "opt-in-status"
    values = ["opt-in-not-required"]
  }
}

Creating 2 blocks for the private subnet and the public subnet

remove the existing code

resource "aws_subnet" "subnet_az1" {
  # for_each   = toset(["192.168.0.0/27", "192.168.0.32/27", "192.168.0.64/27", " 192.168.0.96/27", "192.168.0.128/27", "192.168.0.160/27"])
  for_each          = { "public_subnet_1_az1" : "192.168.0.0/27", "private_subnet_1_az1" : "192.168.0.32/27", "private_subnet_2_az1" : "192.168.0.64/27" }
  vpc_id            = aws_vpc.this.id
  cidr_block        = each.value
  availability_zone = "us-east-1a"

  tags = {
    Name = "Subnet_${each.key}"
  }
}

resource "aws_subnet" "subnet_az2" {
  for_each          = { "public_subnet_1_az2" : "192.168.0.96/27", "private_subnet_1_az2" : "192.168.0.128/27", "priavte_subnet2_az2" : "192.168.0.160/27" }
  vpc_id            = aws_vpc.this.id
  cidr_block        = each.value
  availability_zone = "us-east-1b"

  tags = {
    Name = "Subnet_${each.key}"
  }
}

Suppose we need to create the private subnets fopr all tha availibility zones then add

for_each = { for index, az_name in data.aws_availability_zones.this.names : index => az_name }

for the for_each we are passing out the map datatype as it supports the map and set datatype
index - gives out the index of the subnets and 
az_name -- will give us out the avalibility zones 

data.aws_availability_zones.this -- It will let us know all the availibility zones in the particular region region
eg for us-east gives out 6 AZ
for mumbai fives out 3 AZ

now to get the xact name if the az we could use the attribute reference like "name" 
 data.aws_availability_zones.this.name

Now by this it will only fetch if for the single subnet but we want it for multiple subnets 

so here we requie for loops and In Terraform only for loop is supported not the while loop

for_each = { for index, az_name in data.aws_availability_zones.this.names : index => az_name } // it will give us ourt the o/p inform of map datatype

For map datatype it is a set value os requires in form key : value pairs

so we should add for the for loop as index => az_name

in 1st iteration it will act like for az_name in [us-east1a, us-east-1b...]
and it will iterate throughout the list which we get from the data source

index represents the index of the subnet 
az_name represents the names of the availability_zone


What if we do not want all the avalibilty zones but only some of them like us-east-1a, us-east-1b

Then here wecan follow a modular approach like using the "locals"

using locals we can asign then names to an expression so that we could use names multiple times within a module instead of repeating the expression

NOTE:  Local values are created by a locals block (plural), but you reference them as attributes on an object named local (singular). Make sure to leave off the "s" when referencing a local value!



locals {
  service_name = "forum"
  owner        = "Community Team"
}

and to retrieve vvalues form it 

resource "aws_instance" "example" {
  # ...

  tags = local.common_tags
}

we can use it in our case as 

data "aws_availability_zones" "this" {
}

locals {
  sorted_availability_zones   = sort(data.aws_availability_zones.all.names)
  selected_availability_zones = toset([
    local.sorted_availability_zones[0],
    local.sorted_availability_zones[1],
  ])
}

resource "aws_subnet" "public_subnet" {
  for_each = local.selected_availability_zones

  vpc_id = aws_vpc.this.id
  availability_zone = each.value
}

resource "aws_subnet" "private" {
  for_each = local.selected_availability_zones

  vpc_id = aws_vpc.this.id
  availability_zone = each.value
}

But this would onlyu work if we want the consecutive AZ and from the start


2nd Approach could be as follows like 

data "aws_region" "this" {}

locals {
 az1 = "${data.aws_region.this.name}a"
 az2 = "${data.aws_region.this.name}b"
}


The cidrsubnet(prefix, newbits, netnum) Syntax

prefix: cidr_range of vpc
newbits: how many subnets we need to create let us say 6 i.e. it can be satisfied with the help of 2^3 = 8 so 3 will act as the newbits
netnum(Important): 

eg 10.0.0.0/24 for creating 6 subnets --> 2^3 ie 3 will be new bits
3 bits we will be giving for subnet masking
10.0.0.0/24 in binary representation

8bits + 8bits + 8bits + 8bits = 32 bits 
24 bits already assigned to network
8 bits remains for the host -- out of which 3 we are adding to the host (As a part of adding the subnet)

Only 5 bits are available to the host now


So now 3 bits can be raging from 000 to 111
start from rightmost to the left
2^0 * 1 = 1 (maximum value it can have at that unit position)
2^1 * 1 = 2 (maximum value it can have at that tens position)
2^2 * 1 = 4 (maximum value it can have at that hundredth position)

Adding it up brings out 1 + 2 + 4 = 7(Max value it can obtain) 

7 acts as netnum here


git status --short // gives status befor staging

git log --oneline // gets logs in single line
########################## End Day 10 [] #######################################################